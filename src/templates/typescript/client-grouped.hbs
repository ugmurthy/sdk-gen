{{!-- TypeScript SDK client class with service grouping --}}
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
{{#if hasSchemas}}
import type { {{#each schemaNames}}{{this}}{{#unless @last}}, {{/unless}}{{/each}} } from './types.js';
import { {{#each schemaNames}}{{this}}Schema{{#unless @last}}, {{/unless}}{{/each}} } from './schemas.js';
{{/if}}

export interface {{clientName}}Config {
  baseUrl: string;
  token?: string;
  timeout?: number;
}

{{!-- Generate service classes --}}
{{#each services}}
class {{className}} {
  constructor(private client: AxiosInstance, private baseUrl: string, private getToken: () => string | undefined) {}

{{#each operations}}
{{#unless isStreaming}}
  {{#if summary}}
  /** {{summary}} */
  {{/if}}
  async {{operationId}}({{#if hasParams}}params: {
{{#each pathParameters}}
    {{name}}: {{{tsType}}};
{{/each}}
{{#each queryParameters}}
    {{name}}{{#unless required}}?{{/unless}}: {{{tsType}}};
{{/each}}
{{#if requestBody}}
    body{{#unless requestBody.required}}?{{/unless}}: {{{requestBody.tsType}}};
{{/if}}
  }{{/if}}): Promise<{{{responseType}}}> {
    let url = '{{path}}';
{{#each pathParameters}}
    url = url.replace('{' + '{{name}}' + '}', encodeURIComponent(String(params.{{name}})));
{{/each}}

    const config: AxiosRequestConfig = {
{{#if hasQueryParams}}
      params: {
{{#each queryParameters}}
        {{name}}: params.{{name}},
{{/each}}
      },
{{/if}}
    };

    const response = await this.client.{{lowerMethod}}{{#if requestBody}}<{{{responseType}}}>(url, params.body, config){{else}}<{{{responseType}}}>(url, config){{/if}};
{{#if hasResponseSchema}}
{{#if isListResponse}}
    return response.data.map((item: unknown) => {{responseSchemaName}}Schema.parse(item));
{{else}}
    return {{responseSchemaName}}Schema.parse(response.data);
{{/if}}
{{else}}
    return response.data;
{{/if}}
  }

{{/unless}}
{{/each}}
{{#each operations}}
{{#if isStreaming}}
  {{#if summary}}
  /** {{summary}} */
  {{/if}}
  async *{{operationId}}({{#if hasParams}}params: {
{{#each pathParameters}}
    {{name}}: {{{tsType}}};
{{/each}}
{{#each queryParameters}}
    {{name}}{{#unless required}}?{{/unless}}: {{{tsType}}};
{{/each}}
  }, {{/if}}signal?: AbortSignal): AsyncIterable<{{{responseType}}}> {
    let url = '{{path}}';
{{#each pathParameters}}
    url = url.replace('{' + '{{name}}' + '}', encodeURIComponent(String(params.{{name}})));
{{/each}}
{{#if hasQueryParams}}

    const queryParams = new URLSearchParams();
{{#each queryParameters}}
    if (params.{{name}} !== undefined) queryParams.set('{{name}}', String(params.{{name}}));
{{/each}}
    const queryString = queryParams.toString();
    if (queryString) url += '?' + queryString;
{{/if}}

    const headers: Record<string, string> = {
      'Accept': '{{#if isSse}}text/event-stream{{else}}application/x-ndjson{{/if}}',
    };
    const token = this.getToken();
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }

    const response = await fetch(this.baseUrl + url, {
      method: '{{method}}',
      headers,
      signal,
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    if (!response.body) {
      throw new Error('Response body is null');
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });

{{#if isSse}}
        const events = buffer.split('\n\n');
        buffer = events.pop() || '';

        for (const event of events) {
          if (!event.trim()) continue;
          
          const lines = event.split('\n');
          let data = '';
          
          for (const line of lines) {
            if (line.startsWith('data:')) {
              data += line.slice(5).trim();
            }
          }
          
          if (data) {
            const parsed = JSON.parse(data) as {{{responseType}}};
{{#if hasResponseSchema}}
            yield {{responseSchemaName}}Schema.parse(parsed);
{{else}}
            yield parsed;
{{/if}}
          }
        }
{{else}}
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (!line.trim()) continue;
          const parsed = JSON.parse(line) as {{{responseType}}};
{{#if hasResponseSchema}}
          yield {{responseSchemaName}}Schema.parse(parsed);
{{else}}
          yield parsed;
{{/if}}
        }
{{/if}}
      }

      if (buffer.trim()) {
{{#if isSse}}
        const lines = buffer.split('\n');
        let data = '';
        for (const line of lines) {
          if (line.startsWith('data:')) {
            data += line.slice(5).trim();
          }
        }
        if (data) {
          const parsed = JSON.parse(data) as {{{responseType}}};
{{#if hasResponseSchema}}
          yield {{responseSchemaName}}Schema.parse(parsed);
{{else}}
          yield parsed;
{{/if}}
        }
{{else}}
        const parsed = JSON.parse(buffer) as {{{responseType}}};
{{#if hasResponseSchema}}
        yield {{responseSchemaName}}Schema.parse(parsed);
{{else}}
        yield parsed;
{{/if}}
{{/if}}
      }
    } finally {
      reader.releaseLock();
    }
  }

{{/if}}
{{/each}}
}

{{/each}}
export class {{clientName}} {
  private client: AxiosInstance;
  private baseUrl: string;
  private token?: string;

{{#each services}}
  public readonly {{propertyName}}: {{className}};
{{/each}}

  constructor(config: {{clientName}}Config) {
    this.baseUrl = config.baseUrl.replace(/\/$/, '');
    this.token = config.token;
    this.client = axios.create({
      baseURL: config.baseUrl,
      timeout: config.timeout ?? 30000,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    this.client.interceptors.request.use((reqConfig) => {
      if (this.token) {
        reqConfig.headers.Authorization = `Bearer ${this.token}`;
      }
      return reqConfig;
    });

{{#each services}}
    this.{{propertyName}} = new {{className}}(this.client, this.baseUrl, () => this.token);
{{/each}}
  }

  setToken(token: string): void {
    this.token = token;
  }

{{!-- Include ungrouped operations directly on client --}}
{{#each ungroupedOperations}}
{{#unless isStreaming}}
  {{#if summary}}
  /** {{summary}} */
  {{/if}}
  async {{operationId}}({{#if hasParams}}params: {
{{#each pathParameters}}
    {{name}}: {{{tsType}}};
{{/each}}
{{#each queryParameters}}
    {{name}}{{#unless required}}?{{/unless}}: {{{tsType}}};
{{/each}}
{{#if requestBody}}
    body{{#unless requestBody.required}}?{{/unless}}: {{{requestBody.tsType}}};
{{/if}}
  }{{/if}}): Promise<{{{responseType}}}> {
    let url = '{{path}}';
{{#each pathParameters}}
    url = url.replace('{' + '{{name}}' + '}', encodeURIComponent(String(params.{{name}})));
{{/each}}

    const config: AxiosRequestConfig = {
{{#if hasQueryParams}}
      params: {
{{#each queryParameters}}
        {{name}}: params.{{name}},
{{/each}}
      },
{{/if}}
    };

    const response = await this.client.{{lowerMethod}}{{#if requestBody}}<{{{responseType}}}>(url, params.body, config){{else}}<{{{responseType}}}>(url, config){{/if}};
{{#if hasResponseSchema}}
{{#if isListResponse}}
    return response.data.map((item: unknown) => {{responseSchemaName}}Schema.parse(item));
{{else}}
    return {{responseSchemaName}}Schema.parse(response.data);
{{/if}}
{{else}}
    return response.data;
{{/if}}
  }

{{/unless}}
{{/each}}
}
